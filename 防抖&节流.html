<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
        在节流函数内部使用开始时间startTime
        、当前时间curTime与delay来计算剩余时间remaining，当r
        emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
        执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
        就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
        理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
        新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。
在节流函数内部使用开始时间startTime
、当前时间curTime与delay来计算剩余时间remaining，当r
emaining<=0时表示该执行事件处理函数了（保证了第一次触发事件就能立即
执行事件处理函数和每隔delay时间执行一次事件处理函数）。如果还没到时间的话
就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处
理函数）。当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重
新计算一个remaining来判断当前状态。

总结

函数防抖：将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时
间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。

函数节流：使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。

区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理
函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需
要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请
求数据。这样的场景，就适合用节流技术来实现。

 

参考
</body>
<script>

/**
 *  防抖debounce
 * 函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，
 * 事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，
 * 就重新开始延时。如下图，持续触发scroll事件时，
 * 并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。
*/
// 滚动事件
// window.addEventListener('scroll', debounce(handle, 1000));

// 处理函数
function handle() {    
    // console.log(Math.random()); 
}

// 防抖debounce
function debounce(fn,wait){
    let timer = null;
    if(timer != null) clearTimeout(timer);
    timer = setTimeout(fn,wait);
}





/**
 * 函数节流（throttle）
 * 在节流函数内部使用开始时间startTime、当前时间curTime与delay来计算剩余时间remaining，
 * 当remaining<=0时表示该执行事件处理函数了
 * （保证了第一次触发事件就能立即执行事件处理函数和每隔delay时间执行一次事件处理函数）。
 * 如果还没到时间的话就设定在remaining时间后再触发 （保证了最后一次触发事件后还能再执行一次事件处理函数）。
 * 当然在remaining这段时间中如果又一次触发事件，那么会取消当前的计时器，并重新计算一个remaining来判断当前状态。
 * **/ 
function throttle(fn,delay){
    let timer = null;
    let start = Date.now();
    return ()=>{
        let cur = Date.now();
        let remain = delay - (cur - start);
        if(remain <= 0){
            fn.apply(this,arguments);
            start = Date.now();
        }else{
            timer = setTimeout(fn,remain)
        }
    }
   
}
// 滚动事件
window.addEventListener('scroll', throttle(handle, 1000));
</script>
</html>